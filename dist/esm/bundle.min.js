function e(e,t=!1,r=!0){let n="";n=(e=>{const t=[];for(let r=0;r<e.length;r+=32768)t.push(String.fromCharCode.apply(null,e.subarray(r,r+32768)));return btoa(t.join(""))})("string"==typeof e?(new TextEncoder).encode(e):new Uint8Array(e));return t&&(n=function(e){return e.replace(/\+/g,"-").replace(/\//g,"_")}(n)),r||(n=n.replace(/=/g,"")),n}function t(e,t=!1){{let r=!1;if(/^[0-9a-zA-Z_-]+={0,2}$/.test(e))r=!0;else if(!/^[0-9a-zA-Z+/]*={0,2}$/.test(e))throw new Error("Not a valid base64 input");r&&(e=e.replace(/-/g,"+").replace(/_/g,"/").replace(/=/g,""));const n=new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0))));return t?(new TextDecoder).decode(n):n}}class r{constructor(e,t){this.encrypted=e,this.iv=t}toJSON(){return{encrypted:e(this.encrypted,!0,!1),iv:e(this.iv,!0,!1)}}static fromJSON(e){const n="string"==typeof e?JSON.parse(e):e;return new r(t(n.encrypted),t(n.iv))}}async function n(e=256,t=!1){const r={name:"AES-GCM",length:e};return await crypto.subtle.generateKey(r,t,["encrypt","decrypt"])}async function a(e,t=256,r=!1,n={hash:"SHA-256",iterations:1e5,salt:crypto.getRandomValues(new Uint8Array(16))}){void 0===n.hash&&(n.hash="SHA-256"),void 0===n.iterations&&(n.iterations=1e5),void 0===n.salt&&(n.salt=crypto.getRandomValues(new Uint8Array(16)));const a={name:"PBKDF2",...n},o=await crypto.subtle.importKey("raw",(new TextEncoder).encode(e),"PBKDF2",!1,["deriveKey"]);return{key:await crypto.subtle.deriveKey(a,o,{name:"AES-GCM",length:t},r,["encrypt","decrypt"]),salt:a.salt}}async function o(e){if(!e.extractable)throw new Error("Provided key is not extractable. Consider passing the extractable argument to generateKey or importKey method if you need to extract the key");return await crypto.subtle.exportKey("jwk",e)}async function c(e,t=!1){return void 0!==e.byteLength?await crypto.subtle.importKey("raw",e,{name:"AES-GCM"},t,["encrypt","decrypt"]):await crypto.subtle.importKey("jwk",e,{name:"AES-GCM"},t,["encrypt","decrypt"])}async function i(e,t,n=crypto.getRandomValues(new Uint8Array(16))){const a={name:"AES-GCM",iv:n},o=await crypto.subtle.encrypt(a,t,e);return new r(o,n)}async function s(e,t){const n=e instanceof r?e:r.fromJSON(e),a={name:"AES-GCM",iv:n.iv};return await crypto.subtle.decrypt(a,t,n.encrypted)}export{r as Ciphertext,s as decrypt,a as deriveKey,i as encrypt,o as exportJwk,n as generateKey,c as importKey};
